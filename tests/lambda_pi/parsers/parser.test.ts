import { Application, Ast, Constant, Lambda, MetaVariable, TypeKind, Variable } from "../../../src/lambda_pi/ast";
import { parse, ParseError } from "../../../src/lambda_pi/parsers/lambda_pi_parser";
import { shallow_lambda1, shallow_pi1 } from "../../../src/lambda_pi/ast-examples"
import { app, con, flapp, gv, iv, la, ovlist, pi, type_k } from "../../../src/lambda_pi/shorthands"

function test_parse(name: string, input: string, output: Ast | undefined) {
    const result = parse(input)
    test(`parse ${name}`, () => expect(result).toEqual(output))
}

const [a, b, c, x, y, z] = [new Constant("a"), new Constant("b"), new Constant("c"), new Variable("x"), new Variable("y"), new Variable("z")]
test_parse("Type", "Type", new TypeKind)
test_parse("Type", " Type ", new TypeKind)
// test_parse("Variable 1",  "x:", x)
test_parse("Constant 1", "c", c)
// test_parse("Variable 2",  "y:", y)
test_parse("Constant 2", "b", b)
test_parse("Generated Variable 1", "$cool_-12", gv("cool", -12))
test_parse("Generated Variable 1", "$beans_4", gv("beans", 4))
test_parse("Generated Variable 1", "$_28", iv(28))
// test_parse("Constant", "x", new Constant("x"))
// test_parse("shallow application 1", "c x:", shallow_application1)
test_parse("shallow application 1", "c b", app(c, b))
// test_parse("shallow application 2", "x: c", shallow_application2)
test_parse("shallow application 2", "b c", app(b, c))
// test_parse("deep application 1", "(c x:) (x: c)", deep_application1)
test_parse("deep application 1", "(c b) (b c)", app(app(c, b), app(b, c)))
// test_parse("deep application 2", "(x: c) (c x:)", deep_application2)
test_parse("deep application 2", "(b c) (c b)", app(app(b, c), app(c, b)))
// const repeated_app_left = new Application(new Application(new Application(a, b), c), x)
// test_parse("repeated application left", "a b c x:", repeated_app_left)
const repeated_app_left = new Application(new Application(new Application(a, b), c), a)
test_parse("repeated application left", "a b c a", repeated_app_left)
// const repeated_app_right = new Application(a, new Application(b, new Application(c, x)))
// test_parse("repeated application right", "a (b (c x:))", repeated_app_right)
const repeated_app_right = app(a, app(b, app(c, a)))
test_parse("repeated application right", "a (b (c a))", repeated_app_right)
// const repeated_app_mixed = new Application(new Application(a, new Application(b, c)), x)
// test_parse("repeated application mixed", "a (b c) x:", repeated_app_mixed)
const repeated_app_mixed = new Application(new Application(a, new Application(b, c)), a)
test_parse("repeated application mixed", "a (b c) a", repeated_app_mixed)
test_parse("shallow lambda 1", "L(x : Type).c", shallow_lambda1)
test_parse("shallow lambda 1 parse variable", "L($x_12 : Type).c", la(gv("x", 12), type_k, c))
// test_parse("shallow lambda 2", "L(x : y:).Type", shallow_lambda2)
test_parse("shallow lambda 2", "L(x : b).Type", la(x, b, type_k))
// test_parse("deep lambda 1", "L(x : L(x : Type).c).L(y : y:).Type", deep_lambda1)
test_parse("deep lambda 1", "L(x : L(x : Type).y).L(y : x).Type", la(x, la(x, type_k, con("y")), la(y, x, type_k)))
// test_parse("deep lambda 2", "L(x : L(x : y:).Type).L(x : Type).c", deep_lambda2)
test_parse("deep lambda 2", "L(x : L(x : x).Type).L(x : Type).c", la(x, la(x, con("x"), type_k), la(x, type_k, c)))
test_parse("shallow pi 1", "P(x : Type).c", shallow_pi1)
test_parse("shallow pi 1 parse variable", "L($x_-12 : Type).c", pi(gv("x", -12), type_k, c))
// test_parse("shallow pi 2", "P(y : y:).Type", shallow_pi2)
test_parse("shallow pi 2", "P(x : b).Type", pi(x, b, type_k))
// test_parse("deep pi 1", "P(x : P(x : Type).c).P(y : y:).Type", deep_pi1)
test_parse("deep pi 1", "P(x : P(x : Type).y).P(y : x).Type", pi(x, pi(x, type_k, con("y")), pi(y, x, type_k)))
// test_parse("deep pi 2", "P(x : P(y : y:).Type).P(x : Type).c", deep_pi2)
test_parse("deep pi 2", "P(x : P(x : x).Type).P(x : Type).c", pi(x, pi(x, con("x"), type_k), pi(x, type_k, c)))
test_parse("beta redex", "(L(x: b).x) x", new Application(new Lambda(x, b, x), con("x")))
test_parse("meta-variable by itself", "x?", new MetaVariable("x"))
test_parse("meta-variable in application itself", "x? y", new Application(new MetaVariable("x"), new Variable("y")))
// test_parse("reverse beta redex", "a (L(x: b).z)", new Application(new Lambda(x, b, z), a))
test_parse("error on empty", "", new ParseError("", 'Expected "(", Abstraction, Application, MetaVariable, TypeKind, or VarConst but end of input found.'))

const [maj, min, A, B] = ovlist("maj", "min", "A", "B")
const imp = (x: Ast, y: Ast): Ast => flapp(con("imp"), x, y)
const ml = (x: Ast): Ast => app(con("ml"), x)
const o = con("o")

// Error from sig
test_parse("impe sig", "P(A: o).P(B: o).P(maj: ml (imp A B)).P(min: ml A).ml B", pi(A, o, pi(B, o, pi(maj, ml(imp(A, B)), pi(min, ml(A), ml(B))))))